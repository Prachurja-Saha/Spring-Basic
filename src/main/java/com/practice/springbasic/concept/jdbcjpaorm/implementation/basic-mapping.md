# CasCade

# Fetch Types in Hibernate/JPA: defines when related entities should be loaded from the database.
* 1. `Lazy Fetching (FetchType.LAZY)`:
     Load the associated data of the other entity, only when requested.This is done on demand.
  
    * Example: If a User has many Projects (other entity data), Projects are fetched only when accessed.
    * When you fetch a User entity, the Project collection is not immediately loaded from the database.
    * User user = userRepository.findById(userId).orElse(null);  // Projects not loaded due to lazy
    *
    * // Projects are fetched lazily
    * Set<Project> projects = user.getProjects(); // When you call user.getProjects(),
    * // JPA will execute a query to load the orders from the database at that point.
    *
    * Default Hibernate fetch types:
    *   OneToMany: LAZY
        ManyToOne: EAGER
        ManyToMany: LAZY
        OneToOne: EAGER

* 2. `Eager Fetching (FetchType.EAGER)`: Related entities are loaded immediately with the parent entity.
    * Use Case: Useful when you always need related data, reducing multiple database calls.
    * Example: If a User has a Laptop, Laptop is fetched together with the User.

# @GeneratedValue -> This annotation in JPA is used to specify how the primary key should be generated for an entity.
@GeneratedValue(strategy = GenerationType.IDENTITY) -> create an auto-incremented ID in the table
* GenerationType.IDENTITY strategy means that the primary key will be generated by the database's identity column.
* This approach relies on the database to generate a unique identifier for new rows inserted into the table.
*
* The ID generation is handled by the database, ensuring uniqueness and avoiding conflicts. (Auto Increment)
 

# TSID 
Time-Sorted IDs (TSIDs) are a method of generating unique identifiers that incorporate timestamp information. 

Some of the benefits include:
`Ordered Insertion`: TSIDs help in maintaining the order of insertion based on time, which can be beneficial for 
                     time-series data and improving query performance.
`Scalability`: They are suitable for distributed systems where maintaining a consistent order of events is crucial.
`Human-Readable`: TSIDs can be more human-readable and provide some context about the time of insertion.

# Uni and Bi Directional Mapping

# One To One mapping
In both unidirectional and bidirectional one-to-one mappings, only one table will contain the foreign key column.

In a `unidirectional one-to-one mapping`, 
the foreign key column is created in the table of the entity that holds the reference to the other entity.

In a `bidirectional one-to-one mapping`, 
the foreign key column is created in the table of the entity that owns the relationship. 
Table which have @JoinColumn annotation  and doesn't have mapped by inside OneToOne
@OneToOne(mappedBy = "var_name", cascade = CascadeType.ALL) 

